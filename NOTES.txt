- doesn't appear that there's an ordering between submissions unless explicitely specified by IOSQE_IO_LINK flag
- benchmark test allows for reuse of clients but submits asynchronous commands
  - this means that any write is going to require a copy
- writev is returning errno 22?
  - I'm not sure what's going on here but it may be easier to just have the server on tilly06 (where uring write is defined)
- connection initialization is a pain as it's not a back and forth
  - maybe just turn on uring after connection has been established (see code added to connection.c in commit adding this comment)
- make blocking and batching command line args

Here's a few thoughts:
- we may want to have an io_uring structure per client. this makes it harder to batch syscalls unless we're getting multiple requests from clients at a given time
  - this is worth exploring by running the benchmark and see the number of commands read per client per call to read
- otherwise, we assume that responses can be delivered in any order?

Might be able to improve performance with:
  int io_uring_register(unsigned int fd, unsigned int opcode, void *arg,unsigned int nr_args);

Helpful sites:
- https://kernel.dk/io_uring.pdf
- https://lwn.net/Articles/776703/
- https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/
- https://unixism.net/2020/04/io-uring-by-example-article-series/

Sites to look at:
- https://stackoverflow.com/a/61806870
- http://lse.sourceforge.net/io/aio.html
- https://github.com/python-trio/trio/issues/932
- https://blogs.oracle.com/linux/an-introduction-to-the-io_uring-asynchronous-io-framework
