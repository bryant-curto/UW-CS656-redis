- doesn't appear that there's an ordering between submissions unless explicitely specified by IOSQE_IO_LINK flag
  - The idea now is to batch writes by a client into one submission entry if performing batching. Then, add in a bubble (NOOP + _) after submitting the batch to make sure ordering isn't broke.
  - Must maintain ordering: https://redis.io/topics/pipelining
- benchmark test allows for reuse of clients but submits asynchronous commands
  - this means that any write is going to require a copy
  - I think that this is acceptible
X writev is returning errno 22? (Issue resolved by zeroing out submission queue entry struct)
  - I'm not sure what's going on here but it may be easier to just have the server on tilly06 (where uring write is defined)
X connection initialization is a pain as it's not a back and forth (resolved by not using IO uring for the first few writes)
  - maybe just turn on uring after connection has been established (see code added to connection.c in commit adding this comment)
- make blocking and batching command line args

Here's a few thoughts:
- we may want to have an io_uring structure per client. this makes it harder to batch syscalls unless we're getting multiple requests from clients at a given time
  - this is worth exploring by running the benchmark and see the number of commands read per client per call to read
- otherwise, we assume that responses can be delivered in any order?

Might be able to improve performance with:
  int io_uring_register(unsigned int fd, unsigned int opcode, void *arg,unsigned int nr_args);

THINGS WORK!!
- test PING_INLINE appears to work well (PING_BULK appears to be similar to the inline version but uses building-in function to generate ping message, which I guess results in a "builkier" payload)
- MAKE SURE TO DISABLE CUSTOM LOGGING BEFORE TESTING
- MAKE SURE TO ENABLE OPTIMIZATION BEFORE TESTING
- Do we want to support pipelining? If so, easiest way may be to
  1) check that loop calling uring_connWrite() is the only time it called before epoll
  2) convert written text to iovecs (I believe that they're written back in order)
  3) insert bubble between submissions to ensure that ordering of messages isn't messed up

Fairness of using redis-benchmark for performance analysis: https://redis.io/topics/benchmarks
- i.e. use pipelining

Methods to test:
- `sudo strace -c -p PID` to get info on the number of system calls
  - we can then break that down into reads, writes, io uring submit
- make sure we're not bottlenecked by resources:
  - vmstat for memory (see swap pages)
  - vmstat + htop for cpu usage
  - Write script to calculate inferface saturation using `/sys/class/net/ibo3d1/statistics/{rx_bytes,tx_bytes}`
- redis-benchmark to get throughput (see fairness in benchmarking redis above)

Helpful sites:
- https://kernel.dk/io_uring.pdf
- https://lwn.net/Articles/776703/
- https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/
- https://unixism.net/2020/04/io-uring-by-example-article-series/

Sites to look at:
- https://stackoverflow.com/a/61806870
- http://lse.sourceforge.net/io/aio.html
- https://github.com/python-trio/trio/issues/932
- https://blogs.oracle.com/linux/an-introduction-to-the-io_uring-asynchronous-io-framework
